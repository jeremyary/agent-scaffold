# ADR-0003: Frontend Framework Selection

## Status
Amended (2026-02-16) -- Routing, server state, component library, and testing choices updated for alignment with the ai-quickstart-template standard. Core decision (React + Vite SPA) unchanged. See Amendment section below.

## Context

The application requires five distinct persona experiences sharing a common backend. The frontend stack is not constrained by stakeholder mandates -- the Architect decides. Key requirements:

- Five persona UIs with shared components (chat interface, layout) and persona-specific views (dashboards, pipelines, document upload, audit trail).
- Chat interface with streaming token delivery (WebSocket).
- CEO dashboard with charts and aggregate metrics.
- Document upload with progress and status feedback.
- Single-command setup -- the frontend build must be simple and fast.
- Quickstart developer experience -- the codebase should be approachable for developers evaluating agentic AI patterns (the backend Python code is the primary interest).

The backend team is Python-focused. The frontend is a necessary delivery vehicle, not the primary focus of the Quickstart.

## Options Considered

### Option 1: React with Vite (SPA)
Single-page application using React, built with Vite. TypeScript. Role-based routing after authentication.

- **Pros:** Largest ecosystem for UI components (chat, charts, data tables). Excellent WebSocket support for streaming. Vite provides fast builds and HMR. Rich charting libraries (Recharts, Nivo, Chart.js). React is the most widely understood frontend framework -- lowest barrier for Quickstart users. Good TypeScript support. Straightforward SPA deployment (static files served by nginx or the FastAPI server). No SSR complexity.
- **Cons:** Adds Node.js to the build toolchain (not a runtime dependency -- just build-time). Separate development server during development. Larger bundle than minimal approaches like htmx.

### Option 2: Next.js (SSR/RSC)
Server-rendered React with Next.js.

- **Pros:** Server-side rendering for initial page load. React Server Components for data fetching. File-based routing.
- **Cons:** Adds a Node.js runtime server (not just build-time). Complicates deployment -- now there are two server processes (FastAPI + Next.js). Docker Compose adds another container. SSR benefits are marginal for a chat-heavy application where the primary content is dynamically generated by WebSocket. Increases setup complexity.

### Option 3: htmx with FastAPI Templates (Python-Only)
Server-rendered HTML using Jinja2 templates with htmx for interactivity. No JavaScript framework.

- **Pros:** No Node.js in the stack at all. Python-only toolchain. Simple deployment. Small page sizes.
- **Cons:** Chat streaming with htmx is possible but less natural than WebSocket-based React components. Complex interactive UIs (CEO dashboard with charts, interactive pipeline views, document upload with progress) require significant custom JavaScript anyway, undermining the "no JS framework" benefit. The charting ecosystem is weaker. Quickstart users from financial services are more likely to know React than htmx. The CEO dashboard (F12) with multiple interactive chart types and drill-down would be painful to implement without a charting library.

### Option 4: Streamlit (Python-Only)
Python-based UI framework designed for data applications.

- **Pros:** Python-only. Quick to build data dashboards. Built-in chat interface component.
- **Cons:** Limited customization for persona-specific UIs. Poor WebSocket support for true streaming. Not production-appropriate -- Streamlit apps have reliability issues with streaming and concurrent users. Does not support the single-SPA-with-role-routing pattern well. Not a credible frontend for a "reference architecture" demo.

### Option 5: Gradio / Chainlit (Python-Only, AI-Focused)
Python-based chat UI frameworks designed for AI applications.

- **Pros:** Purpose-built for chat interfaces. Minimal frontend code.
- **Cons:** Too specialized for chat -- the application also needs dashboards, pipeline views, document upload, audit trail browsers. These frameworks do not support the full range of UIs needed. Not extensible enough for Quickstart users who want to add their own UI patterns.

## Decision

**Option 1: React with Vite (SPA).**

The frontend is a delivery vehicle for five distinct persona experiences, several of which require complex interactive UIs (CEO dashboard with charts, pipeline views with urgency indicators, document upload with progress, audit trail browser with multiple query modes). React provides the richest ecosystem for these components.

The single-SPA approach with role-based routing after Keycloak authentication keeps the frontend architecture simple. No server-side rendering -- the SPA connects to the FastAPI backend via HTTP and WebSocket. The frontend builds to static files served by nginx in the Docker Compose setup.

**Specific choices:**
- **Build tool:** Vite (fast builds, good DX)
- **Language:** TypeScript
- **Routing:** React Router with role-based route guards
- **Chat:** Custom WebSocket-based chat component (lightweight, does not need a heavy chat SDK)
- **Charts:** Recharts (React-native charting, sufficient for CEO dashboard)
- **HTTP client:** Standard fetch API with a thin wrapper
- **Auth:** Keycloak JS adapter for OIDC flow
- **Styling:** Tailwind CSS (utility-first, avoids CSS architecture decisions)

**Node.js is build-time only.** The production deployment serves pre-built static files from nginx. No Node.js runtime server. The Docker Compose setup includes a build step but the resulting container is a simple nginx image serving static assets.

## Consequences

### Positive
- Largest component ecosystem for the diverse UI needs (chat, charts, tables, file upload).
- Most widely understood frontend framework -- Quickstart users can modify it.
- Clean SPA architecture -- no SSR complexity.
- Static file deployment is simple and lightweight.
- Excellent streaming support via WebSocket.

### Negative
- Node.js required at build time (not runtime). Adds to developer prerequisites.
- Separate frontend dev server during development (Vite dev server proxying to FastAPI).
- Bundle size is larger than htmx, though this is irrelevant for a PoC running locally.

### Neutral
- TypeScript adds type safety to the frontend, which helps with the data shapes flowing from the Pydantic-validated backend.

## Amendment: Template-Aligned Frontend Stack (2026-02-16)

### Reason for Amendment

The `rh-ai-quickstart/ai-quickstart-template` establishes frontend library choices that we adopt for cross-quickstart consistency and because they are better fits for our application's needs than the original choices.

### Routing: TanStack Router (replaces React Router)

TanStack Router provides file-based, type-safe routing with fully typed params, search params, and loaders. Its `beforeLoad` hooks are a natural fit for role-based routing -- the route definition itself declares the required role:

```typescript
// File-based route: routes/borrower/index.tsx
export const Route = createFileRoute('/borrower/')({
  beforeLoad: ({ context }) => {
    if (context.auth.role !== 'borrower') throw redirect({ to: '/unauthorized' })
  },
})
```

This replaces the custom `ProtectedRoute` wrapper pattern that React Router would require. The trade-off is a smaller community than React Router, which is acceptable for a PoC where the backend is the primary interest.

### Server State: TanStack Query (new)

The original decision stated "no complex data fetching library" targeting Redux/Zustand-style client state managers. TanStack Query is a different category -- it is a server state cache manager that reduces complexity rather than adding it.

Our application has significant polling and data-fetching needs:
- Pipeline dashboard polling for application status changes (Loan Officer)
- Document processing status polling (`GET /api/documents/{id}/status`)
- CEO dashboard with multiple API calls for different metric categories
- Audit trail queries with pagination

Without TanStack Query, each of these requires custom `useEffect` + `useState` patterns, which is more complex and error-prone. TanStack Query provides caching, background refetching, pagination, and optimistic updates declaratively. It also pairs naturally with TanStack Router (shared context, integrated loaders).

### Component Library: shadcn/ui + Radix + CVA (new)

shadcn/ui provides copy-paste components (not an installed dependency) built on Radix primitives for accessibility, using Tailwind CSS under the hood. This complements the existing Tailwind CSS decision -- it is an additive layer, not a replacement. class-variance-authority (CVA) handles variant management for component styling.

The application needs substantial UI components (chat interfaces, data tables, form inputs, modals, tabs, navigation) where building from raw Tailwind CSS is time-consuming and produces inconsistent results. shadcn/ui components are fully customizable since they live in the project source.

### Testing: Vitest + React Testing Library (new)

Vitest is the natural testing framework for Vite projects. React Testing Library provides component testing focused on user behavior rather than implementation details.

### Storybook (available, low priority)

The template includes Storybook for isolated component development. Available from day one but not a PoC priority -- do not invest time configuring stories for every component at PoC maturity.

### Updated Specific Choices

- **Build tool:** Vite (unchanged)
- **Language:** TypeScript (unchanged)
- **Routing:** TanStack Router with file-based routes and `beforeLoad` hooks for role-based access
- **Server state:** TanStack Query for polling, caching, and background refetch
- **Chat:** Custom WebSocket-based chat component (unchanged)
- **Charts:** Recharts (unchanged)
- **HTTP client:** Standard fetch API with TanStack Query wrappers
- **Auth:** Keycloak JS adapter for OIDC flow (unchanged)
- **Styling:** Tailwind CSS + shadcn/ui + Radix primitives + CVA
- **Testing:** Vitest + React Testing Library

### Amended Consequences

- **Positive (added):** TanStack Router's type safety catches routing errors at compile time. TanStack Query eliminates boilerplate for the application's many polling use cases. shadcn/ui provides accessible, consistent components with full customization. Cross-quickstart consistency with the ai-quickstart-template.
- **Negative (added):** TanStack Router has a smaller community than React Router. Additional libraries increase the frontend learning surface for Python-focused developers. Mitigated by the fact that the backend is the primary interest for Quickstart evaluators.
- **Neutral (updated):** The frontend is no longer "no state management library" but it uses server state management (TanStack Query), not client state management (Redux/Zustand). This distinction matters -- TanStack Query reduces complexity for data-fetching-heavy applications.
